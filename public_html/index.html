<!DOCTYPE html>
<html>
    <head>
        <title>Connect the Dots</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="text/css" rel="stylesheet" href="css/main_style.css" />
        <script type="text/javascript" src="js/jquery-1.11.3.min.js"></script>
        <script type="text/javascript" src="js/line-segments-intersect.js"></script>
        <script type="text/javascript">
            // Ensure entire page is rendered in the browser before JS code is executed
            $(document).ready(function()
            {
                console.log('DOM loaded and ready to be manipulated.');
                
                // Set up canvas
                var canvas = document.getElementById("canvas"); // Get element that has id set to "canvas"
                var ctx = canvas.getContext("2d"); // 2D Graphics context
                fitToContainer(canvas); // call method to adjust canvas to the size of the div container 
                canvas.addEventListener("click", placeDot); // Add event listener to place dots on canvas whenever a click happens on canvas box
                
                // Array that contains all the unique dots
                var dotSet = [];
                
                // Array used for permutations
                var permArr = [];
                var usedChars = [];
                var initialOrder = [];
                                    
                // Set onclick event on the submit button
                document.getElementById('submit').onclick = submit;
               
                /**
                 * Gets all the edge-edge relations that intersect.
                 * The end points of the edges connecting do not consider as intersection. 
                 * @param {type} allPossibleEdges
                 * @returns {Array} {edgeOne: {EdgeObj}, edgeTwo: {EdgeObj}}
                 */
                function getAllEdgeToEdgeIntersection(allPossibleEdges)
                {
                    // Array that contains all the possible edges that instersect
                    var allEdgeToEdgeIntersection = [];
                    
                    // Get number of edges in list
                    var numEdges = allPossibleEdges.length;
                    
                    for(var i = 0; i < numEdges; i++)
                    {
                        for(var j = i + 1; j < numEdges; j++)
                        {
                            var currEdge = allPossibleEdges[i];
                            var otherEdge = allPossibleEdges[j];
                                                      
                            // Line Segment One 
                            var line1StartX = currEdge.pointOne.x;
                            var line1StartY = currEdge.pointOne.y;
                            var line1EndX = currEdge.pointTwo.x;
                            var line1EndY = currEdge.pointTwo.y;
                                
                            // Line Segment Two
                            var line2StartX = otherEdge.pointOne.x;
                            var line2StartY = otherEdge.pointOne.y;
                            var line2EndX = otherEdge.pointTwo.x;
                            var line2EndY = otherEdge.pointTwo.y;
                                
                            // Test if line segments are colinear
                            var areColinear = areLineSegmentsColinear(currEdge.pointOne, currEdge.pointTwo, otherEdge.pointOne, otherEdge.pointTwo);
                            console.log("Are Segments Colinear? " + areColinear);
                                
                            // Colinear detected (special case of intersection)
                            if(areColinear)
                            {
                                allEdgeToEdgeIntersection.push({edgeOne: currEdge, edgeTwo: otherEdge});
                            }
                                
                            else
                            {
                                // Call method to test if the two edges intersect
                                var result = checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY);
                                console.log(JSON.stringify(result));
                                
                                // Exclude intersections that are end points of either line segments
                                if((result.x === line1StartX && result.y === line1StartY) || 
                                    (result.x === line2StartX && result.y === line2StartY) ||
                                    (result.x === line1EndX && result.y === line1EndY) || 
                                    (result.x === line2EndX && result.y === line2EndY))
                                {
                                    continue; // skip to next edge-edge relation 
                                }
                           
                                // Intersection detected
                                if(result.onLine1 === true && result.onLine2 === true)
                                {
                                    allEdgeToEdgeIntersection.push({edgeOne: currEdge, edgeTwo: otherEdge});
                                }
                            }
                        }
                    }
                    
                    return allEdgeToEdgeIntersection;
                }
               
                /**
                 * Get all the edges of a complete graph given a set of points.
                 * N = number of dots
                 * Formula for total edges: (N * (N - 1)) / 2
                 * @param {Array} dotSet an array of dotObj, which is represented as {x:<value>,y:<value>} 
                 * @returns an array of edge objects. An edge object is represented
                 * as {pointOne: <dotObject>, pointTwo: <dotObject>}
                 */
                function getAllPossibleEdges(dotSet)
                {
                    var numDots = dotSet.length;
                    
                    // Array that contains all the possible edges for the given dots
                    var allPossibleEdges = [];
                    
                    for(var i = 0; i < numDots; i++)
                    {
                        for(var j = i + 1; j < numDots; j++)
                        {
                            // Add edge to the array. The edge object contains two dot objects.
                            allPossibleEdges.push({pointOne: dotSet[i], pointTwo: dotSet[j]});
                        }
                    }
                    
                    return allPossibleEdges;
                }
                
                /**
                 * Call when the submit button is clicked
                 * @returns {undefined}
                 */
                function submit()
                {
                    var numDots = dotSet.length;
                    console.log("Number of dot elements: " + numDots);
                    
                    var allPossibleEdges = getAllPossibleEdges(dotSet); // call method to get all possible edges given a set of dots
                    console.log("Number of possible edges: " + allPossibleEdges.length); // Complete N graph should have (n(n-1))/2 edges
                    console.log("All possible edges: " + JSON.stringify(allPossibleEdges));
                    
                    var edgeToEdgeIntersections = getAllEdgeToEdgeIntersection(allPossibleEdges); // get all edge-edge relations that form intersections
                    console.log("Edge-Edge Intersections: " + JSON.stringify(edgeToEdgeIntersections));
                    
                    var solution = [];
                    
                    
                    // Populate initial order of iterating through dot array
                    /*for(var i = 0; i < numDots; i++)
                    {
                         initialOrder[i] = i;
                    }
                    
                    // Generate permutations of iterating the dots array 
                    var iteratePermutations = permute(initialOrder); // 2D array // TODO: This is very costly operation; and limits the program to 10 dots
                    console.log(iteratePermutations.length);
                    console.log(JSON.stringify(iteratePermutations)); 
                    
                    // Iterate all permutations of connecting the dots
                    for(var i = 0; i < iteratePermutations.length; i++)
                    {
                        var currentPerm = iteratePermutations[i];
                        //console.log(JSON.stringify(currentPerm));
                        
                        // Store the edges for one permutation of closed shape
                        var edges = []; // {pointOne: {x: 1 , y: 2 }, pointTwo: {x: 5 , y: 7}}
                        
                        // Iterate a single permutation of connecting the dot
                        for(var j = 0; j < currentPerm.length - 1; j++)
                        {
                            var curDotObj = dotSet[currentPerm[j]];
                            var nextDotObj = dotSet[currentPerm[j+1]];
                            edges.push({pointOne: curDotObj, pointTwo: nextDotObj});
                        }
                        
                        // Push last and first points (edge that makes a cycle)
                        edges.push({pointOne: dotSet[currentPerm[currentPerm.length - 1]], pointTwo: dotSet[currentPerm[0]]});
                        //console.log(JSON.stringify(edges));
                        
                        var isCurrentSetValid = true;
                        
                        // Determine if current set of edges is a solution
                        for(var a = 0; a < edges.length; a++)
                        {
                            var currEdge = edges[a];
                            
                            // check current edge with the remaining edges in array
                            for(var b = a + 1; b < edges.length; b++)
                            {
                                var otherEdge = edges[b];
                                
                                // Line Segment One 
                                var line1StartX = currEdge.pointOne.x;
                                var line1StartY = currEdge.pointOne.y;
                                var line1EndX = currEdge.pointTwo.x;
                                var line1EndY = currEdge.pointTwo.y;
                                
                                // Line Segment Two
                                var line2StartX = otherEdge.pointOne.x;
                                var line2StartY = otherEdge.pointOne.y;
                                var line2EndX = otherEdge.pointTwo.x;
                                var line2EndY = otherEdge.pointTwo.y;
                                
                                // Test if line segments are colinear
                                var areColinear = areLineSegmentsColinear(currEdge.pointOne, currEdge.pointTwo, otherEdge.pointOne, otherEdge.pointTwo);
                                console.log("Are Segments Colinear? " + areColinear);
                                
                                // Colinear detected (special case of intersection)
                                if(areColinear)
                                {
                                    isCurrentSetValid = false;
                                    break;
                                }
                                
                                // Call method to test if the two edges intersect
                                var result = checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY);
                                console.log(JSON.stringify(result));
                                
                                // Exclude intersections that are end points of a line segment 
                                // In order words, ensure intersection point is not in the dots list  
                                var isIntersectionPointAnEndPoint = dotSet.some(function(curDotObj)
                                {
                                    return curDotObj.x === result.x && curDotObj.y === result.y;
                                });
                                //console.log(isIntersectionPointAnEndPoint);
                                
                                // If intersection is an endpoint of a line segment, proceed with checking solution 
                                if(isIntersectionPointAnEndPoint)
                                {
                                    continue; // solution still good; skip to check next edge 
                                }
                                
                                // Intersection detected
                                if(result.onLine1 === true && result.onLine2 === true)
                                {
                                    isCurrentSetValid = false;
                                    break;
                                }
                            }
                            
                            if(!isCurrentSetValid)
                            {
                                break;
                            }
                        }
                        
                        // Solution founded
                        if(isCurrentSetValid)
                        {
                            console.log("Solution to iterate dot list: " + JSON.stringify(currentPerm));
                            connectTheDots(currentPerm);
                            break;
                        }
                    }*/
                    
                    // Replace submit button with reset button functionality
                    var submitBtn = document.getElementById("submit");
                    submitBtn.setAttribute("id", "reset");
                    submitBtn.setAttribute("value", "Reset");
                    document.getElementById("reset").onclick = reset;
                    
                    // Remove listener so user cannot modify results
                    canvas.removeEventListener("click", placeDot);
                };
                
                /**
                 * Call when the reset button is clicked.
                 * @param {type} currentPerm
                 * @returns {Arguments}
                 */
                function reset()
                {
                    // Clean up
                    dotSet.length = 0;
                    permArr.length = 0;
                    usedChars.length = 0;
                    initialOrder.length = 0;
                        
                    // Clear canvas
                    ctx.clearRect ( 0 , 0 , canvas.width, canvas.height );
                        
                    // Replace reset button with submit button functionality
                    var resetBtn = document.getElementById("reset");
                    resetBtn.setAttribute("id", "submit");
                    resetBtn.setAttribute("value", "Submit");
                    document.getElementById("submit").onclick = submit;
                    
                    // Add listener
                    canvas.addEventListener("click", placeDot); // Add event listener to place dots on canvas whenever a click happens on canvas box
                };

                /**
                 * Connects the N dots with N lines. Each dot will have two outgoing edges.
                 * There should not be intersection of line segments. 
                 * @param {type} e
                 * @returns {Arguments}
                 */
                function connectTheDots(currentPerm) 
                { 
                    ctx.beginPath(); // Creates a new path 
                    var initialDotObjSet = true;
                    
                    // Iterate dot array by in the order of the permutation array, which contains the indices
                    for(var z = 0; z < currentPerm.length; z++)
                    {
                        dotObj = dotSet[currentPerm[z]];
                        
                        // Set initial coordinate point
                        if(initialDotObjSet)
                        {
                            ctx.moveTo(dotObj.x, dotObj.y); // initial position of pen
                            initialDotObjSet = false;
                        }
                        
                        // Draw line from current point to destination point
                        else
                        {
                            ctx.lineTo(dotObj.x, dotObj.y); // draw straight line to this dot 
                        }
                    } 
                    
                    var initPoint = dotSet[currentPerm[0]];
                    ctx.lineTo(initPoint.x, initPoint.y); // draw line to initial point
                    //ctx.closePath(); // connect last dot with the initial dot
                    ctx.stroke(); 
                }           
                
                /**
                 * Method to place a dot {x-coordinate, y-coordinate} on the canvas grid, which 
                 * is determined by the location of the click. This will also populate
                 * the dotSet<DotObject> array, where DotObject is represented as
                 * {x: <SomeValue>, y: <someValue>}. 
                 * @param e element
                 */
                function placeDot(e)
                {
                    // Normalize the coordinates relative to the canvas area   
                    var parentPosition = getPosition(e.currentTarget);
    
                    // Get the x-coordinate and y-coordinate of the click
                    var xCoordinate = e.clientX - parentPosition.x; // Get x-coordinate of click
                    var yCoordinate = e.clientY - parentPosition.y; // Get y-coordinate of click
                    console.log("(X, Y) = (" + xCoordinate + ", " + yCoordinate + ")"); 
                    
                    // Draw dot that is 5 pixels wide and 5 pixels high on canvas
                    ctx.fillRect(xCoordinate, yCoordinate, 3, 3);
                    
                    // Add dot object to Set
                    var dotObject = {x: xCoordinate, y: yCoordinate}; // store the x and y coordinates of a dot
                    
                    // Determine if dot object already exists in array
                    var doesDotObjExist = dotSet.some(function(curDotObj)
                    {
                        return curDotObj.x === dotObject.x && curDotObj.y === dotObject.y;
                    });
                    
                    // Only add unique dot object to set
                    if(!doesDotObjExist)
                    {
                        dotSet.push(dotObject);
                    }
                }
                
                /**
                 * Algorithm to determine if two given line segments intersect
                 * Source: http://jsfiddle.net/justin_c_rounds/Gd2S2/
                 * @type Arguments
                 */
                function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY)
                {
                    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
                    var denominator, a, b, numerator1, numerator2, result = {
                        x: null,
                        y: null,
                        onLine1: false,
                        onLine2: false
                    };
                    
                    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
                    
                    if (denominator == 0)
                    {
                        return result;
                    }   
    
                    a = line1StartY - line2StartY;
                    b = line1StartX - line2StartX;
                    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
                    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
                    a = numerator1 / denominator;
                    b = numerator2 / denominator;

                    // if we cast these lines infinitely in both directions, they intersect here:
                    result.x = line1StartX + (a * (line1EndX - line1StartX));
                    result.y = line1StartY + (a * (line1EndY - line1StartY));

                    /*
                    // it is worth noting that this should be the same as:
                        x = line2StartX + (b * (line2EndX - line2StartX));
                        y = line2StartX + (b * (line2EndY - line2StartY));
                    */
                    
                    // if line1 is a segment and line2 is infinite, they intersect if:
                    if (a > 0 && a < 1) 
                    {
                        result.onLine1 = true;
                    }
    
                    // if line2 is a segment and line1 is infinite, they intersect if:
                    if (b > 0 && b < 1) 
                    {
                        result.onLine2 = true;
                    }
    
                    // if line1 and line2 are segments, they intersect if both of the above are true
                    return result;
                }
                
                /**
                 * Permute an array 
                 * @type input array of integers 
                 * @return 2D array with all permutations
                 */
                function permute(input) 
                {
                    var i, ch;
                    
                    for (i = 0; i < input.length; i++) 
                    {
                        ch = input.splice(i, 1)[0];
                        usedChars.push(ch);
    
                        if (input.length == 0) 
                        {
                            permArr.push(usedChars.slice());
                        }
    
                        permute(input);
                        input.splice(i, 0, ch);
                        usedChars.pop();                  
                    }
                    
                    return permArr;
                }

                /**
                 * This method is used to normalize the x-coordinate and y-coordinate relative to an area
                 * rather than the entire page.
                 * @param {type} element
                 * @returns object with properties x and y
                 */
                function getPosition(element) 
                {
                    var xPosition = 0;
                    var yPosition = 0;

                    while (element) 
                    {
                        xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
                        yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
                        element = element.offsetParent;
                    }
                    
                    return { x: xPosition, y: yPosition };
                }
        
                /**
                 * Method to adjust the canvas size according to the parent element
                 * @param {type} canvas
                 * @returns {undefined}
                 */
                function fitToContainer(canvas)
                {
                  // Make it visually fill the positioned parent
                  canvas.style.width ='100%';
                  canvas.style.height='100%';
                  
                  // ...then set the internal size to match
                  canvas.width  = canvas.offsetWidth;
                  canvas.height = canvas.offsetHeight;
                }
            });  
        </script>
    </head>
    <body>
        <div id="puzzle" class="dotbox">
            <canvas id="canvas">
            </canvas>
        </div>
        
        <div class="buttonbox">
            <input class="button" type="button" id="submit" value="Solve" />
        </div>
    </body>
</html>
