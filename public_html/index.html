<!DOCTYPE html>
<html>
    <head>
        <title>Connect the Dots</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="text/css" rel="stylesheet" href="css/main_style.css" />
        <script type="text/javascript" src="js/jquery-1.11.3.min.js"></script>
        <script type="text/javascript">
            // Ensure entire page is rendered in the browser before JS code is executed
            $(document).ready(function()
            {
                console.log('DOM loaded and ready to be manipulated.');
                
                var canvas = document.getElementById("canvas"); // Get element that has id set to "canvas"
                var ctx = canvas.getContext("2d"); // 2D Graphics context
                fitToContainer(canvas); // call method to adjust canvas to the size of the div container
                                
                canvas.addEventListener("click", placeDot, true); // Add event listener to place dots on canvas whenever a click happens on canvas box
                
                // Array that contains all the unique dots
                var dotSet = [];
                
                // Array used for permutations
                var permArr = [];
                var usedChars = [];
                var initialOrder = [];
                                    
                // Determine whether submit button is clicked
                document.getElementById('submit').onclick = function()
                {
                    var numDots = dotSet.length;
                    console.log("Number of dot elements: " + numDots);
                    
                    // Iterate dot objects with forEach
                    /*dotSet.forEach(function(dotObj) 
                    {
                        console.log(dotObj);
                    });*/
                                    
                    // Populate initial order of iterating through dot array
                    for(var i = 0; i < numDots; i++)
                    {
                         initialOrder[i] = i;
                    }
                    
                    // Generate permutations of iterating the dots array
                    var iteratePermutations = permute(initialOrder); // 2D array
                    console.log(iteratePermutations.length);
                    //console.log(JSON.stringify(iteratePermutations));
                    
                    // Iterate all permutations of connecting the dots
                    for(var i = 0; i < iteratePermutations.length; i++)
                    {
                        var currentPerm = iteratePermutations[i];
                        //console.log(JSON.stringify(currentPerm));
                        
                        // Store the edges for one permutation of closed shape
                        var edges = []; // {pointOne: {x: 1 , y: 2 }, pointTwo: {x: 5 , y: 7}}
                        
                        // Iterate a single permutation of connecting the dot
                        for(var j = 0; j < currentPerm.length - 1; j++)
                        {
                            var curDotObj = dotSet[currentPerm[j]];
                            var nextDotObj = dotSet[currentPerm[j+1]];
                            edges.push({pointOne: curDotObj, pointTwo: nextDotObj});
                        }
                        
                        // Push last and first points (edge that makes a cycle)
                        edges.push({pointOne: dotSet[currentPerm[currentPerm.length - 1]], pointTwo: dotSet[currentPerm[0]]});
                        //console.log(JSON.stringify(edges));
                        
                        var isCurrentSetValid = true;
                        
                        // Determine if current set of edges is a solution
                        for(var a = 0; a < edges.length; a++)
                        {
                            var currEdge = edges[a];
                            
                            // check current edge with the remaining edges in array
                            for(var b = a + 1; b < edges.length; b++)
                            {
                                var otherEdge = edges[b];
                                
                                // Line Segment One 
                                var line1StartX = currEdge.pointOne.x;
                                var line1StartY = currEdge.pointOne.y;
                                var line1EndX = currEdge.pointTwo.x;
                                var line1EndY = currEdge.pointTwo.y;
                                
                                // Line Segment Two
                                var line2StartX = otherEdge.pointOne.x;
                                var line2StartY = otherEdge.pointOne.y;
                                var line2EndX = otherEdge.pointTwo.x;
                                var line2EndY = otherEdge.pointTwo.y;
                                
                                // Call method to test if the two edges intersect
                                var result = checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY);
                                console.log(JSON.stringify(result));
                                
                                // Exclude intersections that are end points of a line segment 
                                // In order words, ensure intersection point is not in the dots list  
                                var isIntersectionPointAnEndPoint = dotSet.some(function(curDotObj)
                                {
                                    return curDotObj.x === result.x && curDotObj.y === result.y;
                                });
                                //console.log(isIntersectionPointAnEndPoint);
                                
                                // If intersection is an endpoint of a line segment, proceed with checking solution 
                                if(isIntersectionPointAnEndPoint)
                                {
                                    continue; // solution still good; skip to check next edge 
                                }
                                
                                // Intersection detected
                                if(result.onLine1 === true && result.onLine2 === true)
                                {
                                    isCurrentSetValid = false;
                                    break;
                                }
                            }
                            
                            if(!isCurrentSetValid)
                            {
                                break;
                            }
                        }
                        
                        // Solution founded
                        if(isCurrentSetValid)
                        {
                            console.log("Solution to iterate dot list: " + JSON.stringify(currentPerm));
                            connectTheDots(currentPerm);
                            return;
                        }
                        
                    }
                };
                
                function connectTheDots(currentPerm) 
                { 
                    ctx.beginPath(); // Creates a new path 
                    var initialDotObjSet = true;
                    
                    // Iterate dot array by in the order of the permutation array, which contains the indices
                    for(var z = 0; z < currentPerm.length; z++)
                    {
                        dotObj = dotSet[currentPerm[z]];
                        
                        // Set initial coordinate point
                        if(initialDotObjSet)
                        {
                            ctx.moveTo(dotObj.x, dotObj.y); // initial position of pen
                            initialDotObjSet = false;
                        }
                        
                        // Draw line from current point to destination point
                        else
                        {
                            ctx.lineTo(dotObj.x, dotObj.y); // draw straight line to this dot 
                        }
                    } 
                    
                    ctx.closePath(); // connect last dot with the initial dot
                    ctx.stroke(); 
                }           
                
                /**
                 * Method to place a dot on the {x-coordinate, y-coordinate}, which 
                 * is determined by the location of the click.
                 * @type Arguments
                 */
                function placeDot(e)
                {
                    // Normalize the coordinates relative to the canvas area   
                    var parentPosition = getPosition(e.currentTarget);
    
                    // Get the x-coordinate and y-coordinate of the click
                    var xCoordinate = e.clientX - parentPosition.x; // Get x-coordinate of click
                    var yCoordinate = e.clientY - parentPosition.y; // Get y-coordinate of click
                    console.log("(X, Y) = (" + xCoordinate + ", " + yCoordinate + ")"); 
                    
                    // Draw dot that is 5 pixels wide and 5 pixels high on canvas
                    ctx.fillRect(xCoordinate, yCoordinate, 5, 5);
                    
                    // Add dot object to Set
                    var dotObject = {x: xCoordinate, y: yCoordinate}; // store the x and y coordinates of a dot
                    
                    // Determine if dot object already exists in array
                    var doesDotObjExist = dotSet.some(function(curDotObj)
                    {
                        return curDotObj.x === dotObject.x && curDotObj.y === dotObject.y;
                    });
                    
                    // Only add unique dot object to set
                    if(!doesDotObjExist)
                    {
                        dotSet.push(dotObject);
                    }
                }
                
                /**
                 * Algorithm to determine if two given line segments intersect
                 * Source: http://jsfiddle.net/justin_c_rounds/Gd2S2/
                 * @type Arguments
                 */
                function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY)
                {
                    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
                    var denominator, a, b, numerator1, numerator2, result = {
                        x: null,
                        y: null,
                        onLine1: false,
                        onLine2: false
                    };
                    
                    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
                    
                    if (denominator == 0)
                    {
                        return result;
                    }   
    
                    a = line1StartY - line2StartY;
                    b = line1StartX - line2StartX;
                    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
                    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
                    a = numerator1 / denominator;
                    b = numerator2 / denominator;

                    // if we cast these lines infinitely in both directions, they intersect here:
                    result.x = line1StartX + (a * (line1EndX - line1StartX));
                    result.y = line1StartY + (a * (line1EndY - line1StartY));

                    /*
                    // it is worth noting that this should be the same as:
                        x = line2StartX + (b * (line2EndX - line2StartX));
                        y = line2StartX + (b * (line2EndY - line2StartY));
                    */
                    
                    // if line1 is a segment and line2 is infinite, they intersect if:
                    if (a > 0 && a < 1) 
                    {
                        result.onLine1 = true;
                    }
    
                    // if line2 is a segment and line1 is infinite, they intersect if:
                    if (b > 0 && b < 1) 
                    {
                        result.onLine2 = true;
                    }
    
                    // if line1 and line2 are segments, they intersect if both of the above are true
                    return result;
                }
                
                /**
                 * Permute an array 
                 * @type input array of integers 
                 * @return 2D array with all permutations
                 */
                function permute(input) 
                {
                    var i, ch;
                    
                    for (i = 0; i < input.length; i++) 
                    {
                        ch = input.splice(i, 1)[0];
                        usedChars.push(ch);
    
                        if (input.length == 0) 
                        {
                            permArr.push(usedChars.slice());
                        }
    
                        permute(input);
                        input.splice(i, 0, ch);
                        usedChars.pop();                  
                    }
                    
                    return permArr;
                }

                /**
                 * This method is used to normalize the x-coordinate and y-coordinate relative to an area
                 * rather than the entire page.
                 * @param {type} element
                 * @returns object with properties x and y
                 */
                function getPosition(element) 
                {
                    var xPosition = 0;
                    var yPosition = 0;

                    while (element) 
                    {
                        xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
                        yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
                        element = element.offsetParent;
                    }
                    
                    return { x: xPosition, y: yPosition };
                }
        
                /**
                 * Method to adjust the canvas size according to the parent element
                 * @param {type} canvas
                 * @returns {undefined}
                 */
                function fitToContainer(canvas)
                {
                  // Make it visually fill the positioned parent
                  canvas.style.width ='100%';
                  canvas.style.height='100%';
                  
                  // ...then set the internal size to match
                  canvas.width  = canvas.offsetWidth;
                  canvas.height = canvas.offsetHeight;
                }
            });  
        </script>
    </head>
    <body>
        <div id="puzzle" class="dotbox">
            <canvas id="canvas">
            </canvas>
        </div>
        
        <div class="buttonbox">
            <input class="button" type="button" id="submit" value="Solve" />
        </div>
    </body>
</html>
